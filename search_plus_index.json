{"./":{"url":"./","title":"Introduction","keywords":"","body":"C Programming Tutorial "},"Lecture 1.html":{"url":"Lecture 1.html","title":"Lecture 1","keywords":"","body":"Lecture 1 Computers, Programs, and Programming Language This lecture presents a gentle introduction to what a computer is and how it operates. It shows the functional parts of a computer, and shows how those parts work together to carry out sequences of instructions that solve problems. We also briefly explore what is meant by a computer program, and how the program is loaded and run by a computer. Next, we look at how a computer programming language enables a developer to create programs. We will see that programming languages can range from low-level, corresponding to native instructions that the computer perfors, to mid-level ones that can easily be translated to native instructions, to high-level ones tha require the support of additional layeers of software. Finally, we take a first look at the C programming language that we will use for this course, a simple, mid-level language which provides features that make it relatively simple to learn and use. It also strongly influenced several higher-level languages, including C++ and Java, that will also be used in throughout the graduate curriculum. Lecture "},"Lecture 2.html":{"url":"Lecture 2.html","title":"Lecture 2","keywords":"","body":"Lecture 2 Program Basics: Types, Statements, Operators, and Expressions This lesson covers the basics of a program, which includes both data and instructions. It begins by introducing the idea of a data type. Almost every programming language associates data with types. As we saw in Lecture 1, a value stored in memory occupies a certain number of bytes, and computer instructions are designed to operate on data of specific types. These data types and instructions are directly reflected in the C programming language. The C language allows a developer to identify a value in memory by a symbolic name called a variable that indicates its purpose and its data type. This enables a compiler that translates a C program into computer instructions to use the appropriate instructions for the type. The term \"variable\" is used because the value of that memory may be changed by the program. Next the lessson shows how C instructions in the form of statements can be executed one after another to implement a program that performs a particular task. Statements consist of expressions that combine values and operators. Operators transform input values into an output values that can be used as input to other operators. The results are ultimately stored in memory for later use. C enables writing even complicated expressons very compactly, using a notation that is similar to standard mathematical notaton. This lesson reviews the built-in C operators for various data types, and illustrates the many ways that data and operators can be combined into expressions and statements. Lecture "},"Lecture 3.html":{"url":"Lecture 3.html","title":"Lecture 3","keywords":"","body":"Lecture 3 Defining and Calling Functions Functions are a way to create new operations that can be combined with built-in operators and other functions. There are two purposes for defining functions. One is to specify some functionality just once and then reuse it wherever it is needed, rather than repeating the same sequence of statements for each new set of values. The other purpose is to make the program more understandable by replacing a sequence of statements with the use of a function whose name describes what it does. This is often referred to as encapsulation. The process of designing a program that breaks a complex problem into a set of functions that are easier to design, use, test, and maintain is known as functional decomposition. In this lesson, we will learn how to define a function with formal parameters that are place-holders for actual values the function uses, and how to return the result of the function. Then we will see how to call the function with actual parameter values, and use the returned result. We will also survey a few of the libraries of pre-defined functions that C provides. Finally, we will look at a few examples of functional decomposition to understand this important design paradigm. Lecture "},"Identifiers and types.html":{"url":"Identifiers and types.html","title":"Identifiers and types","keywords":"","body":"Identifiers and types Identifiers Identifiers are names of variable, arrays, function, structures, unions and labels. Type bool: 1 byte (8 bits) char, (signed char), unsigned char: 1 byte (8 bits) short (signed short), unsigned short: 2 bytes (16 bits) int (signed int), unsigned int : 4 bytes (32 bits) long (signed long), unsigned long: 8 bytes (64 bits) long long (signed long long), unsigned long long : 8 bytes (64 bits) float: 4 bytes (32 bits) double: 8 bytes (64 bits) long double: 16 bytes (80 bits) (note: 10 bytes stored in 16 byte field) String String is sequence of characters. The void type A function returns void. A function has no parameter can accept void. Pointers to void. a memory allocation function void *malloc( size_t size ) return a pointer to void which can be casted to any type of data. Constant variable Constant variable #define identifier value. const type identifier = value. Print Format specifiers in printf format string. bool: %d, %i char: %c short: %d, %i unsigned short: %u int: %d, %i unsigned int: %u long: %ld, %li unsigned long: %lu long long: %lld, %lli (see note) unsigned long long: %llu (see note) float: %f double: %f long double: %Lf string: %s Pointer address: %p Assignments operator We would declare a variable like this type variable_name. We would use assignments operator = to initialize a variable like this variable_name = value. We would initialize a variable in their declaration like this type variable_name = value. Arithmetic operators Infix binary operators: +, -, *, /, %. Prefix unary operators: ++, --, +, -. Postfix unary operators: ++, --. Arithmetic assignment operators: +=, -=, *=, /=, %=. int count = 0; int count1 = ++count; // count1 is 1, count is 1 int count2 = count++; // count2 is 1, count is 2 count *= count; // count is 4 Relational operators equals ==. not equal !=. greater >. less . greater or equal >=. less or equal . Logical operators logical AND &&. logical OR ||. logical NOT !. Misc Operators Conditional operator ?. Returns the size of a variable sizeof(). Returns the address of a variable &. Pointer to a variable *. Assignment Define and initialize the following variable or constant with the appropriate type and value. In some cases, you will use operators to compute the value. An unsigned integer constant squareOfThree initialized by calculating the square of 3 A double precision floating point constant e initialized to Euler's constant 2.718281828459045 A boolean variable isGreaterThan initialized to the logical expression 2.8 > e An integer variable quotient initialized to the ratio of sum 2+4+5 divided by 3 A short integer variable remainder that is the remainder of 11 with 3 A double precision variable greaterValue that is 2.8 if isGreaterThan is true and e if isGreaterThan is false. A single precision floating point constant oneTenth initialized to the ratio of 1.0 divided by 10.0 A character hex7A whose value is the hexadecimal constant 7A. A character constant charZ initialized to 'Z'. An unsigned short variable numLetters that is the number of letters between 'A' and 'Z' inclusive. For each variable or constant, provide a printf() statement using the apropriate field specifier that prints its name, its value, and its size in bytes. Programming #include #include unsigned int countCalls(bool reset); void testCountCalls(); double pi(); unsigned short daysInMonth(unsigned int month); int main() { // CountCalls testCountCalls(); // Approximates value of pi to the precision of a double: 3.14159265358979 printf(\"pi is %.14f \\n\", pi()); // The number of days in month printf(\"The number of days is %d \\n\", daysInMonth(12)); } /** * countCalls * @param reset * @return If called with false, the function increments problem1Count and returns 0. * If called with true, the function resets * problem1Count to 0 and returns the number * of times the function was called since * the last time it was reset. * Does: Increment problem1count. */ // Create a function unsigned int countCalls(bool reset) with a static unsigned in // problem1Count to count the number of times the function is called static unsigned problem1count; unsigned int countCalls(bool reset) { unsigned int count; if (!reset) { // The function increments problem1Count and returns 0 problem1count++; return 0; } else { // The function resets // problem1Count to 0 and returns the number // of times the function was called since // the last time it was reset. count = problem1count; problem1count = 0; return count; } } /** * Call problem1count function several times with false to build up a count, then call it with true. * Report the value returned from the function for each call. By way of example, * if the function is called four times with false, it returns 0 each time. * If then called with true, it returns 4 and resets problem1Count back to 0. */ void testCountCalls() { // If we call the function four times with false, it returns 0 each time. printf(\"The function returns %d \\n\", countCalls(false)); printf(\"The function returns %d \\n\", countCalls(false)); printf(\"The function returns %d \\n\", countCalls(false)); printf(\"The function returns %d \\n\", countCalls(false)); // If we call the function with true, it returns 4 and resets problem1Count back to 0. printf(\"The function returns %d \\n\", countCalls(true)); // The function has been called with true, so the problem1Count is reset to 0. // If we call the function two times with false, it returns 0 each time. printf(\"The function returns %d \\n\", countCalls(false)); printf(\"The function returns %d \\n\", countCalls(false)); // If we call the function with true, it returns 2 and resets problem1Count back to 0. printf(\"The function returns %d \\n\", countCalls(true)); } /** * pi * @return Use a loop to add successive terms of the series until the previous sum and sum * with the next term are the same. * Return this value as the result of the function */ double pi() { double successiveNumber = 2.0f; double pi = 3.0f; double sumWithPreviousTerm; double sumWithNextTerm; while (true) { pi = pi + 4 / (successiveNumber * (successiveNumber + 1) * (successiveNumber + 2)); successiveNumber = successiveNumber + 2; sumWithPreviousTerm = pi; pi = pi - 4 / (successiveNumber * (successiveNumber + 1) * (successiveNumber + 2)); successiveNumber = successiveNumber + 2; sumWithNextTerm = pi; if (sumWithPreviousTerm == sumWithNextTerm) { return pi; } } } /** * daysInMonth * @param The function takes a month number between 1 (Janauary) and 12 (December) * @return number of days in any month (assuming 28 for February). If the input value is not a valid month number, * return 0 from the function. */ unsigned short daysInMonth(unsigned int month) { if (month 12) { return 0; } unsigned short numDays = 0; switch (month) { case 2: numDays = 28; break; case 1: case 3: case 5: case 7: case 8: case 10: case 12: numDays = 31; break; case 4: case 6: case 9: case 11: numDays = 30; break; } return numDays; }assignment-2.c "},"Function.html":{"url":"Function.html","title":"Function","keywords":"","body":"Function Function Reusability. Understandable. Productivity. C function Each function definition has the general form. // Documentation /** * Description of function. * @param param1 description of param1 * … * @param paramN description of paramN * @return description of return value */ // Function definition. return-type function-name (type1 param1, … , typeN paramN) { // Function Body statement-1; … statement-M; // Return statement returns return-value to caller return return-value; } We would declare a function, call a function in main() and define a function like this #include /* function declaration */ // Parameter names are not important in function declaration only their type is required. // We would declare a function like this // int max(int, int); int max(int num1, int num2); int main () { /* local variable definition */ int a = 100; int b = 200; int ret; /* calling a function to get max value */ ret = max(a, b); printf( \"Max value is : %d\\n\", ret ); return 0; } /* function returning the max between two numbers */ /* Function definition */ int max(int num1, int num2) { /* local variable declaration */ int result; if (num1 > num2) result = num1; else result = num2; return result; } scope Scope Visibility of variable. Local variable Variables declared within a function block are local variables and they are known only to that function. Variables declared outside the function are unknown to the function. Global variable A global variable is a variable that is declared outside all functions. A global variable can be used in all functions. Let's say that the first function is main() and additional functions are defined after main(). The variables declared above main() are global variables. The static qualifier. /** @file cfile1.c */ /** This function is visible only within this file*/ static void function1(void) { … } /** This function is visible everywhere in the global scope */ void function2(void) { function1(); } /** @file cfile2.c */ /** This variable is visible only within this file*/ static int variable1; /** This variable is visible everywhere in the global scope */ int variable2; "},"Lecture 4.html":{"url":"Lecture 4.html","title":"Lecture 4","keywords":"","body":"Lecture 4 Decision Making, Conditional Processing, and Repetition The sequence of instructions to perform often depends on values that were computed by previous instructions. If a certain value is less than another value, for example, one sequence of instructions applies, otherwise a different sequence of instructions is performed. The C language provides conditional processing constructs that control which sequence of instructions to perform. These constructs are controlled by logical expressions that combine built-in C logical and comparison operators and functions. Some computations require repeating a set of instructions, using the results of previous instructions or repetitions to determine whether to continue repeating the instructions. The C language provides several conditional processing constructs called loops that repeat a set of instructions until a logical expression becomes false or while a logical expression evaluates as true. In this lesson, we will look at the various conditional processing constructs provided by the C language, and also see how these constructs can be combined to implement more advanced conditional processing operations. Lecture "},"Conditional process.html":{"url":"Conditional process.html","title":"Conditional process","keywords":"","body":"Conditional process if else if for loop switch Swich case statements can only be used with numbers, characters or Enums. They cannot be used for processing strings or classes. while loop Assignment Include all the specified functions in a file \"assignment-2.c\". Include a main program that tests the functions by calling them with test data and printing the results returned by the functions. Include comments for the tests that describe their purposes. Label the output so someone else can understand it. Provide a documentation block for for the file that includes the name of the file, its creation date, its author, and a brief description the file. Also provide a documentation block each function describing its purpose, parameters, and return values as appropriate. Check your file in to the CCIS GitHub repository 2018FACS5001SV/assignment-2-ccisID that was created by your instructor for your ccisID. Function countCalls Create a function unsigned int countCalls(bool reset) with a static unsigned in problem1Count to count the number of times the function is called. If called with false, the function increments problem1Count and returns 0. If called with true, the function resets problem1Count to 0 and returns the number of times the function was called since the last time it was reset. Call this function from main several times with false to build up a count, then call it with true. Report the value returned from the function for each call. By way of example, if the function is called four times with false, it returns 0 each time. If then called with true, it returns 4 and resets problem1Count back to 0. Function pi Write a function double pi() that approximates value of pi to the precision of a double: 3.14159265358979 using an approximation technique that is the sum of the series 3 + 4/(2*3*4) - 4/(4*5*6) + 4/(6*7*8) - 4/(8*9*10) ... Use a loop to add successive tems of the series until the previous sum and sum with the next term are the same. Return this value as the result of the function. Function daysInMonth Write a function unsigned short daysInMonth(unsigned int month). The function takes a month number between 1 (Janauary) and 12 (December), and uses a switch statement to set a local unsigned short variable numDays to the number of days in any month (assuming 28 for February). Return numDays at the end of the function. If the input value is not a valid month number, return 0 from the function. Be sure to include this behaviour in your function documenation. Programming #include #include unsigned int countCalls(bool reset); void testCountCalls(); double pi(); unsigned short daysInMonth(unsigned int month); int main() { // CountCalls testCountCalls(); // Approximates value of pi to the precision of a double: 3.14159265358979 printf(\"pi is %.14f \\n\", pi()); // The number of days in month printf(\"The number of days is %d \\n\", daysInMonth(12)); } /** * countCalls * @param reset * @return If called with false, the function increments problem1Count and returns 0. * If called with true, the function resets * problem1Count to 0 and returns the number * of times the function was called since * the last time it was reset. * Does: Increment problem1count. */ // Create a function unsigned int countCalls(bool reset) with a static unsigned in // problem1Count to count the number of times the function is called static unsigned problem1count; unsigned int countCalls(bool reset) { unsigned int count; if (!reset) { // The function increments problem1Count and returns 0 problem1count++; return 0; } else { // The function resets // problem1Count to 0 and returns the number // of times the function was called since // the last time it was reset. count = problem1count; problem1count = 0; return count; } } /** * Call problem1count function several times with false to build up a count, then call it with true. * Report the value returned from the function for each call. By way of example, * if the function is called four times with false, it returns 0 each time. * If then called with true, it returns 4 and resets problem1Count back to 0. */ void testCountCalls() { // If we call the function four times with false, it returns 0 each time. printf(\"The function returns %d \\n\", countCalls(false)); printf(\"The function returns %d \\n\", countCalls(false)); printf(\"The function returns %d \\n\", countCalls(false)); printf(\"The function returns %d \\n\", countCalls(false)); // If we call the function with true, it returns 4 and resets problem1Count back to 0. printf(\"The function returns %d \\n\", countCalls(true)); // The function has been called with true, so the problem1Count is reset to 0. // If we call the function two times with false, it returns 0 each time. printf(\"The function returns %d \\n\", countCalls(false)); printf(\"The function returns %d \\n\", countCalls(false)); // If we call the function with true, it returns 2 and resets problem1Count back to 0. printf(\"The function returns %d \\n\", countCalls(true)); } /** * pi * @return Use a loop to add successive terms of the series until the previous sum and sum * with the next term are the same. * Return this value as the result of the function */ double pi() { double successiveNumber = 2.0f; double pi = 3.0f; double sumWithPreviousTerm; double sumWithNextTerm; while (true) { pi = pi + 4 / (successiveNumber * (successiveNumber + 1) * (successiveNumber + 2)); successiveNumber = successiveNumber + 2; sumWithPreviousTerm = pi; pi = pi - 4 / (successiveNumber * (successiveNumber + 1) * (successiveNumber + 2)); successiveNumber = successiveNumber + 2; sumWithNextTerm = pi; if (sumWithPreviousTerm == sumWithNextTerm) { return pi; } } } /** * daysInMonth * @param The function takes a month number between 1 (Janauary) and 12 (December) * @return number of days in any month (assuming 28 for February). If the input value is not a valid month number, * return 0 from the function. */ unsigned short daysInMonth(unsigned int month) { if (month 12) { return 0; } unsigned short numDays = 0; switch (month) { case 2: numDays = 28; break; case 1: case 3: case 5: case 7: case 8: case 10: case 12: numDays = 31; break; case 4: case 6: case 9: case 11: numDays = 30; break; } return numDays; }assignment-2.c "},"Lecture 5.html":{"url":"Lecture 5.html","title":"Lecture 5","keywords":"","body":"Lecture 5 Arrays and Strings In this lesson, we will learn about arrays as a way to create collections of fixed size elements of the same type. Arrays allow implementing operatoins that operate on the entier array, as well as on individual elements. We will begin with how an array stored in memory, and how to access the elements of an array using a non-negative index. Then we will see how to declare an array valued variable and specify the size of the array. Next, we will learn how to use multi-dimensional arrays to represent data that is naturally oriented towards this kind of representation, sucn as images. Finally, we will learn how the C languages uses arrays to represesnt textaual information using a special type of character array called a string. Strings enable a number of operations for manuiplating string based information and well look at some of them, and create even some ourselves. Lecture "},"Array.html":{"url":"Array.html","title":"Array","keywords":"","body":"Arrays Array Array is a collection of variables of the same type. Array index. Declare array array type array name [array size] int arr [6]. Declare and initialize array array type array name [array size] = {array element} int arr [6] = {1, 2, 3, 4, 5, 6} int arr [] = {1, 2, 3, 4, 5, 6}. 2D array Declare 2D array array type array name [number of rows][number of columns] int arr [3][3]. Declare and initialize 2D array array type array name [number of rows][number of columns] = {array element}. int array [3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; int array [][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; [info] 2D array When declaring a 2D array, the number of columns is required. 3D array Declare and initialize 3D array array type array name [number of rows][number of columns][index of element] = {array element}. int array [3][3][3] = {{10, 20, 30}, {40, 50, 60}, {70, 80, 90}}, {{15, 25, 35}, {45, 55, 65}, {75, 85, 95}}, {{16, 26, 36}, {46, 56, 66}, {76, 86, 96}}; String Initialize string char hello[ 6] = { 'H', 'e', 'l', 'l', 'o', '\\ 0'}; char hello[ ] = { 'H', 'e', 'l', 'l', 'o', '\\ 0'}; char hello[ ] = \"Hello\"; // compiler supplies '\\0' Assignment DUE DATE: Wed, 19 Sept by 11:59:59pm Include all the specified functions in a file \"assignment-3.c\". Include a main program that calls the functions with test data and prints the results returned by the functions. Label the output so someone else can understand it. You must provide a documentation block for each function describing its purpose, parameters, and return values as appropriate. Check your file in to the CCIS GitHub repository 2017FACS5001SV/assignment-3-ccisID that was created by your instructor for your ccisID. Problem 1 Write a function void initArray(unsigned int n, int array[], int value) that initializes all n elements of the input array to the specified value. Test the function in the main() function by calling it with arrays of size 0, 1, and one or two other small sizes, and printing the array on return. Be sure to label the output so someone reading it can verify the result. Here are some examples for int arrays a0 of lenght 0, a1 of length 1, etc. initArray(0, a0, 25) result: { } initArray(1, a1, 42) result: { 42 } initArray(3, a3, 88) result: { 88, 88, 88 } initArray(6, a6, 14) result: { 14, 14, 14, 14, 14, 14 } Problem 2 Write a function int wordCount(char str[]) that counts the number of words in the input string and return the count as the function result. A word is a sequence of characters that does not contain a space character (' '). The final word will end with the '\\0' end of string character. Use local counters, and a loop to implement this function. (Hint: what is the reliationship between the number of spaces and the number of words if just one space separates words?) Test this function by passing it test strings and verifying that function returns the expected word count. Here are several examples for you to use in testing: \"\" length: 0, word count: 0 \"the\" length: 3, word count: 1 \"two words\" length: 9, word count: 2 \"the quick brown fox\" length: 19, word count: 4 Although it is not required, consider how to make your function work corectly if there could multiple spaces before and afterwords. Programming #include #include #include void initArray(unsigned int size, int array[], int element); void testInitArray(); int wordCount(char str[]); void testWordCount(); int main() { // Test initArray function testInitArray(); // Test wordCount function testWordCount(); } /** * initArray * @param size size of array * @param array we use array to store value * @param element the element of array * Does Initializes all n elements of the input array to the specified value */ void initArray(unsigned int size, int array[], int element) { for (int i = 0; i assignment-3.c "},"Lecture 6.html":{"url":"Lecture 6.html","title":"Lecture 6","keywords":"","body":"Lecture 6 Pointers and Pointer Function Parameters Every variable in C occupies a memory location when the program is in memory, and every location has a address. C provides a special data type known as a pointer to represent the address, and special operators for getting the address of a variable and for getting the value at that address. The pointer type and the operators provide a number of new ways for a program to access and operate on data. In this lecture we will learn about pointers types and the address-of and value-at operators, and how to use them to implement a new type of function parameter passing scheme known as Call By Reference (CBR). We will look at several examples to understand how ponters work and ways to use CBR to implement functions that would be difficult to do in any other way. In the next lecture, we will look at other ways to use pointers for operating on arrays and strings. Lecture "},"Pointers and Pointer Function Parameters.html":{"url":"Pointers and Pointer Function Parameters.html","title":"Pointers and Pointer Function Parameters","keywords":"","body":"Pointers and Pointer Function Parameters Address Address prefix operator &. Printf format specifier to print pointer is %p. Pointer Declare pointer Declare pointer type *variableName. bool *bp; // pointer to a boolean char *ch; // pointer to a character short *sp; // pointer to a short int *ip; // pointer to an integer long *lp; // pointer to a long long long *lp; // pointer to a long float *fp; // pointer to a float double *dp; // pointer to a double long double *ldp; // pointer to a long double Pointer would be used for: Parameter passing Passing functions to other functions Alternative way to access arrays Accessing interior fields of structures Working with dynamic storag Pointer implementation Swap value of two variables. Offsets a point x and y by an offset offX and offY. "},"Lecture 7.html":{"url":"Lecture 7.html","title":"Lecture 7","keywords":"","body":"Lecture 7 Pointers to Arrays and Strings This lecture looks at the relationship between pointers and arrays. Arrays are a natural use for pointers because they reprresent contigously allocated blocks of memory that are often addressed sequentially. As we will see, the sequential access pattern makes it attractive to use pointers rather than array indexing operations to access data. Using pointers avoids an additional set of address arithmetic calculations that must be performed each time. We will also look at how arrays are passed to functions, and how the C compiler translates C operations written in terms of arrays into equivalent pointer operations on the arrays. In this way, C arrays are actually passed to functions by reference because it is the address of the array that is being passed by value. Finally, we will look at how the C string functions use pointers to implement more string operations, including ones we have already seen and new ones that provide more advance operations. Lecture "},"Pointers to Arrays and Strings.html":{"url":"Pointers to Arrays and Strings.html","title":"Pointers to Arrays and Strings","keywords":"","body":"Pointers to Arrays and Strings Pointers to Arrays We would use pointer to access array element. int arr[] = {1, 2, 3, 4, 5, 6}; int *arrptr = arr; for (int i = 0; i [info] Pointers to Arrays The pointer arrptr points to the location of the first array element. The arr is the address of the first array element. The arr + i is the address of the ith array element. The *arrptr is the content of array element. The arrptr = arr + 0 is the array element in index 0. The arrptr = arr + i is the element in index i. int *arrayPointer = arr; for (int i = 0; i [info] Pointers to Arrays This would be more efficient. Pointers to strings The atoi() function. /** This function returns an int representing * the integer value of the string. * * @param str the input string * @param the integer represented by the string * @return the integer value for the input string */ int atoiTest(const char *str) { while (isspace(*str)) { str++; } bool negtive = false; if (*str == '-') { negtive = true; str++; } int result = 0; for (; isdigit(*str); ++str) { int digit = *str - '0'; result = (10 * result) + digit; } if (negtive) { return -result; } return result; } Assignment DUE DATE: Mon, 24 Sept by 11:59:59pm Coming soon. Tic Tac Toe Game You will implement several functions in a Tic Tac Toe game. I have already implemented the main that will call the functions you have to write. The board will be stored in a 2 dimensional 3x3 array of char. Implement the following functions: initBoard(char board[3][3]) – This function initializes the 3x3 board array to space characters representing unmarked positions. displayBoard(char board[3][3]) – This displays the tic-tac-toe board with vertical and horizontal grid lines formed with dashes and vertical bars, using the characters in the 3x3 board array. | X | O | | | | O | | | O | X | X | markTheBoard(char board[3][3], char mark, int position) – This function marks the board based on the position (1-9) and marker character passed in. hasWon(char board[3][3], char mark) – Returns true if the marker character of the player passed in as won the game by examining the values in the 3x3 board array. isTie(char board[3][3]) – Tells if the board is currently a tie. You will use the code in your repository, which is under 2018FACS5001SV/assignment-4-CCIS_ID. Programming #include #include #include const int ROW = 3; const int COLUMN = 3; /** * initBoard initializes the 3x3 board array to space characters representing unmarked positions * @param board */ void initBoard(char board[ROW][COLUMN]) { for (int i = 0; i 9 || board[(boardPos - 1) / 3][(boardPos - 1) % 3] != ' ') { continue; } validInput = true; } // mark the position and display the updated board markTheBoard(board, turn, boardPos); // display the current board displayBoard(board); // other player's turn switch (turn) { case 'X': turn = 'O'; break; case 'O': turn = 'X'; break; } } // game over so report results // this order is not the most efficient if (isTie(board)) { printf(\"The game ends in a tie.\\n\"); } else if (hasWon(board, 'X')) { printf(\"Player X has won.\"); } else { printf(\"Player O has won.\"); } }assignment-4.c "},"Lecture 8.html":{"url":"Lecture 8.html","title":"Lecture 8","keywords":"","body":"Lecture 8 Introduction to Types and Using Typedefs to Define New Types In this lesson, we will look at the concept of data types, and the ways that data types can be defined in the C programming language. We will discover that there are five common ways to create new data types: references, sequences, aliases, enumerations, and aggregations. We have already studied two of these. A pointer indirectly refers to a value through the address of the value that is stored in a pointer variable. An array is an indexable homogeneous sequence of a basic data type such as boolean, int, float, and char, or a pointer to one of those types. In this lesson, we will learn about typedef, a way to provide programmer-defined names to existing basic types, and to composites of existing types. As we will see, being able to name new and existing types offers several benefits, including program portability on different processors and operating systems, and definitions that are more meaningful in terms application-specific concepts like Color. This greatly improves the readability of code and facitates the ability to matain and add new functionality over time. Lecture "},"Lecture 9.html":{"url":"Lecture 9.html","title":"Lecture 9","keywords":"","body":"Lecture 9 Using Enums to Define New Types The second of the three new mechanisms for defining types is the enumeration. An enumeration defines a type in terms of a set of symbolic constants that repesent the values of the type. For example, days of the week can be defined in terms of their day number, but it is clearer to provide symbolic constants that name the days, and to use those constants rather than their numeric day numbers. In this lecture, we will look at the use of the C language enum to define enumerated types, including how to define an enum, how to specify symbolic constants, how to print their values, and how to make use of them as parameters, switches, and loop and array indexes. We will also learn about some of the limitations and restrictions on enum values in C, and why it is almost always beneficial to typedef an enum. Lecture "},"Lecture 10.html":{"url":"Lecture 10.html","title":"Lecture 10","keywords":"","body":"Lecture 10 Using Structs to Define New Types The third and final mechanism allows creating new types as heterogenous collections of existing types. A struct consists of a set of named fields. Each field is specified by an identifier with a name and a type. A struct can be used to represent information about a real-world object in an application, such as a book with an author, title, publisher, and publication date in a library management system. In this lecture, we will learn how to define a struct, how to define and name its fields, how to initialize structs, and how to get and set individual fields. We will also see how to create more complex data types by embedding struct, enum, and typedef type fields within a struct. Finally, we will learn why it is almost always beneficial to typedef a struct. Lecture "},"Data type and typedefs.html":{"url":"Data type and typedefs.html","title":"Data type and typedefs","keywords":"","body":"Data type and typedefs C programming language data type bool, char, short, int, long, float, and double. Define References provide indirect access to values of another data type.Sequences are indexable homogeneous collections of another data type.Aliases provide an alternate name for another data type.Enumerations explicitly identify collections of discrete values that comprise data types. Aggregations are heterogeneous combinations of other data types. typedef A typedef is an alias for an existing data type. It does not create a new type in any sense; it merely adds a new name for some existing type. We would declare the typedef like this typedef existing-type new-type. typedef int Length; Length len, maxlen; Length *lengths[]; typedef char *String; String p, lineptr[MAXLINES], alloc(int) int strcmp(String, String); p = (String) malloc(100); [info] Primative Data Types Parameterize a program against portability problems. Provide better documentation for a program. Enum An enum is an enumerated type that specifies a fixed set of choices. We would use enum to avoid \"magic number\" which is a numeric constant that appears in your code without explanation. We would declare the enum like this enum identifier(opt) {enumerator-list}. typedef enum { Sun, Mon, Tue, Wed, Thu, Fri, Sat } DayOfWeek; // This is the same as // const int Sun = 0; This makes DayOfWeek a type, similar to int. As with any type, we can declare variables of that type. int main(){ DayOfWeek homeWorkDueDay = Tue; printf(\"%d \", homeWorkDueDay); } Playing card #include #include /* * Card suit and value */ typedef uint8_t Card; /* * Card suit */ typedef enum { hearts, diamonds, clubs, spades } CardSuit; /* * Card value */ typedef enum { ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king } CardValue; /* * Name of card suit */ const char *cardSuit[] = {\"hearts\", \"diamonds\", \"clubs\", \"spades\"}; /* * Name of value */ const char *cardValue[] = {\"\", \"ace\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"jack\", \"queen\", \"king\"}; /** * makeCard * @param suit * @param value * @return Card suit and value */ Card makeCard(CardSuit suit, CardValue value) { return suit > 4; } /** * cardToString * @param card * @param str * @return Card string */ char *cardToString(Card card, char *str) { int value = getCardValue(card); int suit = getCardSuit(card); sprintf(str, \"%s of %s\", cardValue[value], cardSuit[suit]); return str; } int main() { char cardStr[20]; for (CardSuit suit = hearts; suit PlayingCard.c Struct Array is the collection of the same type data. Likewise, struct is the collection of the different type data. Struct is an aggregation of heterogeneous types that represent a record. #include #include // Define struct struct Books{ char title[100]; char author[100]; char subject[100]; int book_id; }; int main(){ // Declare struct struct Books book1; struct Books book2; // Assign struct strcpy(book1.author, \"Allen\"); strcpy(book1.title, \"C Programming\"); strcpy(book1.subject, \"Computer\"); book1.book_id = 123456; // Access struct printf(\"%s\\n\", book1.title); printf(\"%d\", book1.book_id); return 0; } #include #include // define struct struct Books { char title[100]; char author[100]; char subject[100]; int book_id; }; // struct as function parameter void printBook(struct Books books) { printf(\"%s\\n\", books.title); printf(\"%d\\n\", books.book_id); } int main(){ // declare struct struct Books book_one; struct Books book_two; // assign struct strcpy(book_one.title, \"Programming\"); book_one.book_id = 123456; strcpy(book_one.subject, \"Computer\"); // call the printBook function printBook(book_one); return 0; } Assignment DUE DATE: Fri, 29 Sept before 11:59:59pm A zoo is a collection of animals. We can represent animals using an enum Animal whose identifiers are the animal names. For this assignment, our zoo has the following kinds of animal in its collection: anteater bear cheetah elephant giraffe lion monkey rhinoceros tiger zebra We can represent a Zoo as a typedef for an array of Animal whose elements count the number of each Animal in its collection. The value of each Animal can be used as an index into the Zoo array. Write a C program \"zoo.c\" that creates and manages a zoo. Create an Animal enum for the animals listed above in that order, and add Animal_kinds at the end of the enum as the number of kinds of Animals. Create a Zoo typedef as an array of unsigned int representing the counts for each kind of Animal in the Zoo's collection. Write a function void makeZoo(Zoo aZoo) that initializes the Zoo to have no Animals in its collection. Write a function unsigned int addAnimal(Zoo aZoo, Animal anAnimal) that adds an Animal to the Zoo and returns the current count for that Animal. Write a function const char* getAnimalName(Animal anAnimal) that returns the name of the Animal. Declare a local array static const char *animalNames[], initialized with the literal strings for the Animal names using the Animal enumeration value as an index into the animalNames array. The function can return the string because the animalNames is a static array of literal strings. Write a function void printZoo(const Zoo aZoo) that prints an inventory of the animals in the Zoo. The output is one animal per line with the count in a blank-padded field of 3 digits (%3u), followed by a tab character ('\\t') followed by the name of the animal.The function uses getAnimalNames() to get the Animal names. Write a int main(void) function that creates a Zoo and calls makeZoo() to initialize it. Then it calls addAnimal() to add a number of each Animal to the Zoo corresponding to the enumeration value of the Animal. For each Animal added, it prints the Animal name and the new count using this format: \"Added %s count: %u\\n\" Finally it uses printZoo() to print animals in the Zoo and their counts. Programming #include #include #include // Create an Animal enum for the animals listed above in that order, // and add Animal_kinds at the end of the enum as the number of kinds of Animals typedef enum { anteater, bear, cheetah, elephant, giraffe, lion, monkey, rhinoceros, tiger, zebra } Animal; // Create a Zoo typedef as an array of unsigned int // representing the counts for each kind of Animal in the Zoo's collection. const int Animal_kinds = 10; typedef unsigned int Zoo[Animal_kinds]; // Write a function void makeZoo(Zoo aZoo) that initializes the Zoo to // have no Animals in its collection. /** * makeZoo * @param aZoo * Does initializes the Zoo to have no Animals in its collection */ void makeZoo(Zoo aZoo) { for (int i = 0; i zoo.c Assignment DUE DATE: Wed, 3 Oct before 11:59:59pm This problem is similar to the example shown on slides 21-24 of Lecture 3. Write a program \"assignment-6.c\" that creates and manages geometric shapes. Define and typedef a struct Point that contains two double variables x and y. An instance of Point represents a point in Cartsian space. Define and typedef a struct Circle that contains a double variable radius and a Point variable center. Define and typedef a struct Rectangle that contains a Point variable origin that is the top left corner of the rectangle, and two double variables width and height. Create a function distanceofPoints() that takes const pointers to two Point structs, and computes the distance between them. The distance between two points is the square root of the square of the x distances plus the square of the y distances for the two points. The function returns a double. Create a function intersectsCircles() that takes const pointers to two Circle structs circle1 and circle2and returns true if the two circles intersect and false otherwise. Two circles intersect if the distance between their centers is less than the sum of the two radii (if they are equal, the two circles touch but do not intersect. Create a function getBoundingBox() that takes a const pointer to a in input parameter Circle, circle and a pointer to a Rectangle result parameter boundingBox. The function sets the fields of Rectangle to the bounding box that encloses the circle. The function returns the Rectangle result parameter pointer. Create a main program that tests the intersectsCircles() function using the following cases: circle1 at 0,0 radius 10, and circle2 at 21,0, radius 10: do not intersect circle1 at 0,0 radius 10, and circle3 at 20, 0, radius 10: do not intersect circle1 at 0,0 radius 10, and circle4 at 19,0, radius 10: intersect Also in the main program, test the getBoundingBox() function by declaring an uninitialized Rectangle boundingBox and calling the getBoundingBox() function for circle1, circle2, circle3, and circle4. Print the origin, width, and height of the boundingBox for each circle. Programming #include #include #include #include struct Point { double x; double y; }; struct Circle { double radius; struct Point center; }; struct Rectangle { struct Point origin; double width; double height; }; double distanceofPoints(const struct Point point_one, const struct Point point_two) { return sqrt(pow(point_one.x - point_two.x, 2) - pow(point_one.y - point_two.y, 2)); } bool intersectsCircles(const struct Circle circle_one, const struct Circle circle_two) { return distanceofPoints(circle_one.center, circle_two.center) origin.x = circle.center.x - circle.radius; boundingBox->origin.y = circle.center.y + circle.radius; boundingBox->height = circle.radius * 2; boundingBox->width = circle.radius * 2; return boundingBox; } int main() { struct Circle circle_one; circle_one.radius = 10.0; circle_one.center.x = 0.0; circle_one.center.y = 0.0; struct Circle circle_two; circle_two.radius = 10.0; circle_two.center.x = 21.0; circle_two.center.y = 0.0; struct Circle circle_three; circle_three.radius = 10.0; circle_three.center.x = 20.0; circle_three.center.y = 0.0; struct Circle circle_four; circle_four.radius = 10.0; circle_four.center.x = 19.0; circle_four.center.y = 0.0; if (intersectsCircles(circle_one, circle_two)) { printf(\"intersect\\n\"); } else { printf(\"do not intersect\\n\"); } if (intersectsCircles(circle_one, circle_three)) { printf(\"intersect\\n\"); } else { printf(\"do not intersect\\n\"); } if (intersectsCircles(circle_one, circle_four)) { printf(\"intersect\\n\"); } else { printf(\"do not intersect\\n\"); } struct Rectangle boundingBox; getBoundingBox(circle_one, &boundingBox); printf(\"%f, %f, %f, %f\\n\", boundingBox.origin.x, boundingBox.origin.y, boundingBox.width, boundingBox.height); getBoundingBox(circle_two, &boundingBox); printf(\"%f, %f, %f, %f\\n\", boundingBox.origin.x, boundingBox.origin.y, boundingBox.width, boundingBox.height); getBoundingBox(circle_three, &boundingBox); printf(\"%f, %f, %f, %f\\n\", boundingBox.origin.x, boundingBox.origin.y, boundingBox.width, boundingBox.height); getBoundingBox(circle_four, &boundingBox); printf(\"%f, %f, %f, %f\\n\", boundingBox.origin.x, boundingBox.origin.y, boundingBox.width, boundingBox.height); return 0; }assignment-6.c "},"Lecture 11.html":{"url":"Lecture 11.html","title":"Lecture 11","keywords":"","body":"Lecture 11 Memory Management In this lecture, we will learn about how memory is managed in a C program, including the stack, the constant pool, and the heap. We will also learn about functions that enable us to use the C heap for dynamically creating and managing data in a this portion of memory that is independent of fixed global storage and the local storage within a given function. Lecture "},"Memory allocation and management.html":{"url":"Memory allocation and management.html","title":"Memory allocation and management","keywords":"","body":"Memory allocation and management malloc and calloc #include #include #include int main() { char name[100]; strcpy(name, \"Allen\"); printf(\"%s\\n\", name); char *sentence; // Dynamic memory allocation sentence = malloc(200 * sizeof(char)); // Initialize allocated memory strcpy(sentence, \"Allen is a computer science student\"); // Print string printf(\"%s\\n\", sentence); char *paragraph; // Dynamic memory allocation paragraph = calloc(200, sizeof(char)); // Initialize allocated memory strcpy(paragraph, \"Kevin is a computer science student.\"); // Print string printf(\"%s\\n\", paragraph); return 0; } strlen #include #include #include int main() { char *sentence; // Dynamic memory allocation sentence = malloc(strlen(\"Computer science student. \")); // Initialize allocated memory strcpy(sentence, \"student\"); // Print string printf(\"%s\\n\", sentence); return 0; } strdup #include #include #include int main() { char *words; // Initialize string words = strdup(\"Allen is a computer science student. \"); // Print string printf(\"%s\\n\", words); return 0; } realloc and free #include #include #include int main() { char name[100]; strcpy(name, \"Allen\"); printf(\"%s\\n\", name); char *sentence; // Dynamic memory allocation sentence = malloc(200 * sizeof(char)); // Initialize allocated memory strcpy(sentence, \"Allen is a computer science student. \"); // Print string printf(\"%s\\n\", sentence); char *paragraph; // Dynamic memory allocation paragraph = calloc(100, sizeof(char)); // Initialize allocated memory strcpy(paragraph, \"Kevin is a computer science student. \"); // Print string printf(\"%s\\n\", paragraph); // Increase the size of an allocated memory paragraph = realloc(paragraph, 200 * sizeof(char)); // Concatenate to extended memory strcat(paragraph, \"Kevin is a programmer. \"); // Print string printf(\"%s\\n\", paragraph); // Release memory free(paragraph); return 0; } realloc strlen and free #include #include #include int main() { char *words; // Memory allocation words = malloc(strlen(\"Computer science student. \")); // Initialize memory strcpy(words, \"student \"); // Print string printf(\"%s\\n\", words); // Increase the size of allocated memory words = realloc(words, strlen(\"Programming \")); // Concatenate to extended memory strcat(words, \"Programming\"); // Print string printf(\"%s\\n\", words); // Release memory free(words); return 0; } "}}